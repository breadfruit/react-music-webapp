{"ast":null,"code":"/**version:1.0.0\n * 传入歌词，按照正则表达式解析\n * 解析的数据结构为：\n * {\n *   txt:歌词，\n *   time:ms\n * }\n */\n// eslint-disable-next-line\nconst timeExp = /\\[(\\d{2,}):(\\d{2})(?:[\\.\\:](\\d{2,3}))?]/g;\nconst STATE_PAUSE = 0;\nconst STATE_PLAYING = 1;\nconst tagRegMap = {\n  title: 'ti',\n  artist: 'ar',\n  album: 'al',\n  offset: 'offset',\n  by: 'by'\n};\n\nfunction noop() {}\n\nexport default class Lyric {\n  constructor(lrc) {\n    let hanlder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n    let speed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    this.lrc = lrc;\n    this.tags = {};\n    this.lines = [];\n    this.handler = hanlder;\n    this.state = STATE_PAUSE;\n    this.curLineIndex = 0;\n    this.speed = speed;\n    this.offset = 0;\n\n    this._init();\n  }\n\n  _init() {\n    this._initTag();\n\n    this._initLines();\n  }\n\n  _initTag() {\n    for (let tag in tagRegMap) {\n      const matches = this.lrc.match(new RegExp(`\\\\[${tagRegMap[tag]}:([^\\\\]]*)]`, 'i'));\n      this.tags[tag] = matches && (matches[1] || '');\n    }\n  }\n\n  _initLines() {\n    const lines = this.lrc.split('\\n');\n\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      let result = timeExp.exec(line);\n\n      if (result) {\n        const txt = line.replace(timeExp, '').trim();\n\n        if (txt) {\n          if (result[3].length === 3) {\n            result[3] = result[3] / 10;\n          }\n\n          this.lines.push({\n            time: result[1] * 60 * 1000 + result[2] * 1000 + (result[3] || 0) * 10,\n            txt\n          });\n        }\n      }\n    }\n\n    this.lines.sort((a, b) => {\n      return a.time - b.time;\n    });\n  }\n\n  _findcurLineIndex(time) {\n    for (let i = 0; i < this.lines.length; i++) {\n      if (time <= this.lines[i].time) {\n        return i;\n      }\n    }\n\n    return this.lines.length - 1;\n  }\n\n  _callHandler(i) {\n    if (i < 0) {\n      return;\n    }\n\n    this.handler({\n      txt: this.lines[i].txt,\n      lineNum: i\n    });\n  }\n\n  _playRest() {\n    let isSeek = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let line = this.lines[this.curLineIndex];\n    let delay;\n\n    if (isSeek) {\n      delay = line.time - (+new Date() - this.startStamp);\n    } else {\n      //拿到上一行的歌词开始时间，算间隔\n      let preTime = this.lines[this.curLineIndex - 1] ? this.lines[this.curLineIndex - 1].time : 0;\n      delay = line.time - preTime;\n    }\n\n    this.timer = setTimeout(() => {\n      this._callHandler(this.curLineIndex++);\n\n      if (this.curLineIndex < this.lines.length && this.state === STATE_PLAYING) {\n        this._playRest();\n      }\n    }, delay / this.speed);\n  }\n\n  changeSpeed(speed) {\n    this.speed = speed;\n  }\n\n  play() {\n    let offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let isSeek = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (!this.lines.length) {\n      return;\n    }\n\n    this.state = STATE_PLAYING;\n    this.curLineIndex = this._findcurLineIndex(offset); //现在正处于第this.curLineIndex-1行\n\n    this._callHandler(this.curLineIndex - 1);\n\n    this.offset = offset;\n    this.startStamp = +new Date() - offset;\n\n    if (this.curLineIndex < this.lines.length) {\n      clearTimeout(this.timer);\n\n      this._playRest(isSeek);\n    }\n  }\n\n  togglePlay(offset) {\n    if (this.state === STATE_PLAYING) {\n      this.stop();\n      this.offset = offset;\n    } else {\n      this.state = STATE_PLAYING;\n      this.play(offset, true);\n    }\n  }\n\n  stop() {\n    this.state = STATE_PAUSE;\n    this.offset = 0;\n    clearTimeout(this.timer);\n  }\n\n  seek(offset) {\n    this.play(offset, true);\n  }\n\n}","map":{"version":3,"sources":["/Users/macos/Desktop/react-music-webapp/src/api/lyric-parser.js"],"names":["timeExp","STATE_PAUSE","STATE_PLAYING","tagRegMap","title","artist","album","offset","by","noop","Lyric","constructor","lrc","hanlder","speed","tags","lines","handler","state","curLineIndex","_init","_initTag","_initLines","tag","matches","match","RegExp","split","i","length","line","result","exec","txt","replace","trim","push","time","sort","a","b","_findcurLineIndex","_callHandler","lineNum","_playRest","isSeek","delay","Date","startStamp","preTime","timer","setTimeout","changeSpeed","play","clearTimeout","togglePlay","stop","seek"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,OAAO,GAAG,0CAAhB;AAEA,MAAMC,WAAW,GAAG,CAApB;AACA,MAAMC,aAAa,GAAG,CAAtB;AAEA,MAAMC,SAAS,GAAG;AAChBC,EAAAA,KAAK,EAAE,IADS;AAEhBC,EAAAA,MAAM,EAAE,IAFQ;AAGhBC,EAAAA,KAAK,EAAE,IAHS;AAIhBC,EAAAA,MAAM,EAAE,QAJQ;AAKhBC,EAAAA,EAAE,EAAE;AALY,CAAlB;;AAQA,SAASC,IAAT,GAAgB,CACf;;AAED,eAAe,MAAMC,KAAN,CAAY;AACzBC,EAAAA,WAAW,CAACC,GAAD,EAAiC;AAAA,QAA3BC,OAA2B,uEAAjBJ,IAAiB;AAAA,QAAXK,KAAW,uEAAH,CAAG;AAC1C,SAAKF,GAAL,GAAWA,GAAX;AACA,SAAKG,IAAL,GAAY,EAAZ;AACA,SAAKC,KAAL,GAAa,EAAb;AACA,SAAKC,OAAL,GAAeJ,OAAf;AACA,SAAKK,KAAL,GAAajB,WAAb;AACA,SAAKkB,YAAL,GAAoB,CAApB;AACA,SAAKL,KAAL,GAAaA,KAAb;AACA,SAAKP,MAAL,GAAc,CAAd;;AAEA,SAAKa,KAAL;AACD;;AAEDA,EAAAA,KAAK,GAAG;AACN,SAAKC,QAAL;;AAEA,SAAKC,UAAL;AACD;;AAEDD,EAAAA,QAAQ,GAAG;AACT,SAAK,IAAIE,GAAT,IAAgBpB,SAAhB,EAA2B;AACzB,YAAMqB,OAAO,GAAG,KAAKZ,GAAL,CAASa,KAAT,CAAe,IAAIC,MAAJ,CAAY,MAAKvB,SAAS,CAACoB,GAAD,CAAM,aAAhC,EAA8C,GAA9C,CAAf,CAAhB;AACA,WAAKR,IAAL,CAAUQ,GAAV,IAAiBC,OAAO,KAAKA,OAAO,CAAC,CAAD,CAAP,IAAc,EAAnB,CAAxB;AACD;AACF;;AAEDF,EAAAA,UAAU,GAAG;AACX,UAAMN,KAAK,GAAG,KAAKJ,GAAL,CAASe,KAAT,CAAe,IAAf,CAAd;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,KAAK,CAACa,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACrC,YAAME,IAAI,GAAGd,KAAK,CAACY,CAAD,CAAlB;AACA,UAAIG,MAAM,GAAG/B,OAAO,CAACgC,IAAR,CAAaF,IAAb,CAAb;;AACA,UAAIC,MAAJ,EAAY;AACV,cAAME,GAAG,GAAGH,IAAI,CAACI,OAAL,CAAalC,OAAb,EAAsB,EAAtB,EAA0BmC,IAA1B,EAAZ;;AACA,YAAIF,GAAJ,EAAS;AACP,cAAIF,MAAM,CAAC,CAAD,CAAN,CAAUF,MAAV,KAAqB,CAAzB,EAA4B;AAC1BE,YAAAA,MAAM,CAAC,CAAD,CAAN,GAAYA,MAAM,CAAC,CAAD,CAAN,GAAU,EAAtB;AACD;;AACD,eAAKf,KAAL,CAAWoB,IAAX,CAAgB;AACdC,YAAAA,IAAI,EAAEN,MAAM,CAAC,CAAD,CAAN,GAAY,EAAZ,GAAiB,IAAjB,GAAwBA,MAAM,CAAC,CAAD,CAAN,GAAY,IAApC,GAA2C,CAACA,MAAM,CAAC,CAAD,CAAN,IAAa,CAAd,IAAmB,EADtD;AAEdE,YAAAA;AAFc,WAAhB;AAID;AACF;AACF;;AAED,SAAKjB,KAAL,CAAWsB,IAAX,CAAgB,CAACC,CAAD,EAAIC,CAAJ,KAAU;AACxB,aAAOD,CAAC,CAACF,IAAF,GAASG,CAAC,CAACH,IAAlB;AACD,KAFD;AAID;;AAEDI,EAAAA,iBAAiB,CAACJ,IAAD,EAAO;AACtB,SAAK,IAAIT,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKZ,KAAL,CAAWa,MAA/B,EAAuCD,CAAC,EAAxC,EAA4C;AAC1C,UAAIS,IAAI,IAAI,KAAKrB,KAAL,CAAWY,CAAX,EAAcS,IAA1B,EAAgC;AAC9B,eAAOT,CAAP;AACD;AACF;;AACD,WAAO,KAAKZ,KAAL,CAAWa,MAAX,GAAoB,CAA3B;AACD;;AAEDa,EAAAA,YAAY,CAACd,CAAD,EAAI;AACd,QAAIA,CAAC,GAAG,CAAR,EAAW;AACT;AACD;;AACD,SAAKX,OAAL,CAAa;AACXgB,MAAAA,GAAG,EAAE,KAAKjB,KAAL,CAAWY,CAAX,EAAcK,GADR;AAEXU,MAAAA,OAAO,EAAEf;AAFE,KAAb;AAID;;AAEDgB,EAAAA,SAAS,GAAe;AAAA,QAAdC,MAAc,uEAAP,KAAO;AACtB,QAAIf,IAAI,GAAG,KAAKd,KAAL,CAAW,KAAKG,YAAhB,CAAX;AACA,QAAI2B,KAAJ;;AACA,QAAGD,MAAH,EAAW;AACTC,MAAAA,KAAK,GAAGhB,IAAI,CAACO,IAAL,IAAa,CAAC,IAAIU,IAAJ,EAAD,GAAc,KAAKC,UAAhC,CAAR;AACD,KAFD,MAEM;AACJ;AACA,UAAIC,OAAO,GAAG,KAAKjC,KAAL,CAAW,KAAKG,YAAL,GAAoB,CAA/B,IAAoC,KAAKH,KAAL,CAAW,KAAKG,YAAL,GAAoB,CAA/B,EAAkCkB,IAAtE,GAA6E,CAA3F;AACAS,MAAAA,KAAK,GAAGhB,IAAI,CAACO,IAAL,GAAYY,OAApB;AACD;;AACD,SAAKC,KAAL,GAAaC,UAAU,CAAC,MAAM;AAC5B,WAAKT,YAAL,CAAkB,KAAKvB,YAAL,EAAlB;;AACA,UAAI,KAAKA,YAAL,GAAoB,KAAKH,KAAL,CAAWa,MAA/B,IAAyC,KAAKX,KAAL,KAAehB,aAA5D,EAA2E;AACzE,aAAK0C,SAAL;AACD;AACF,KALsB,EAKnBE,KAAK,GAAG,KAAKhC,KALM,CAAvB;AAMD;;AAEDsC,EAAAA,WAAW,CAACtC,KAAD,EAAQ;AACjB,SAAKA,KAAL,GAAaA,KAAb;AACD;;AAEDuC,EAAAA,IAAI,GAA6B;AAAA,QAA5B9C,MAA4B,uEAAnB,CAAmB;AAAA,QAAhBsC,MAAgB,uEAAP,KAAO;;AAC/B,QAAI,CAAC,KAAK7B,KAAL,CAAWa,MAAhB,EAAwB;AACtB;AACD;;AACD,SAAKX,KAAL,GAAahB,aAAb;AAEA,SAAKiB,YAAL,GAAoB,KAAKsB,iBAAL,CAAuBlC,MAAvB,CAApB,CAN+B,CAO/B;;AACA,SAAKmC,YAAL,CAAkB,KAAKvB,YAAL,GAAkB,CAApC;;AACA,SAAKZ,MAAL,GAAcA,MAAd;AACA,SAAKyC,UAAL,GAAkB,CAAC,IAAID,IAAJ,EAAD,GAAcxC,MAAhC;;AAEA,QAAI,KAAKY,YAAL,GAAoB,KAAKH,KAAL,CAAWa,MAAnC,EAA2C;AACzCyB,MAAAA,YAAY,CAAC,KAAKJ,KAAN,CAAZ;;AACA,WAAKN,SAAL,CAAeC,MAAf;AACD;AACF;;AAEDU,EAAAA,UAAU,CAAChD,MAAD,EAAS;AACjB,QAAI,KAAKW,KAAL,KAAehB,aAAnB,EAAkC;AAChC,WAAKsD,IAAL;AACA,WAAKjD,MAAL,GAAcA,MAAd;AACD,KAHD,MAGO;AACL,WAAKW,KAAL,GAAahB,aAAb;AACA,WAAKmD,IAAL,CAAU9C,MAAV,EAAkB,IAAlB;AACD;AACF;;AAEDiD,EAAAA,IAAI,GAAG;AACL,SAAKtC,KAAL,GAAajB,WAAb;AACA,SAAKM,MAAL,GAAc,CAAd;AACA+C,IAAAA,YAAY,CAAC,KAAKJ,KAAN,CAAZ;AACD;;AAEDO,EAAAA,IAAI,CAAClD,MAAD,EAAS;AACX,SAAK8C,IAAL,CAAU9C,MAAV,EAAkB,IAAlB;AACD;;AAjIwB","sourcesContent":["/**version:1.0.0\n * 传入歌词，按照正则表达式解析\n * 解析的数据结构为：\n * {\n *   txt:歌词，\n *   time:ms\n * }\n */\n// eslint-disable-next-line\nconst timeExp = /\\[(\\d{2,}):(\\d{2})(?:[\\.\\:](\\d{2,3}))?]/g\n\nconst STATE_PAUSE = 0\nconst STATE_PLAYING = 1\n\nconst tagRegMap = {\n  title: 'ti',\n  artist: 'ar',\n  album: 'al',\n  offset: 'offset',\n  by: 'by'\n}\n\nfunction noop() {\n}\n\nexport default class Lyric {\n  constructor(lrc, hanlder = noop, speed = 1) {\n    this.lrc = lrc\n    this.tags = {}\n    this.lines = []\n    this.handler = hanlder\n    this.state = STATE_PAUSE\n    this.curLineIndex = 0\n    this.speed = speed\n    this.offset = 0\n\n    this._init()\n  }\n\n  _init() {\n    this._initTag()\n\n    this._initLines()\n  }\n\n  _initTag() {\n    for (let tag in tagRegMap) {\n      const matches = this.lrc.match(new RegExp(`\\\\[${tagRegMap[tag]}:([^\\\\]]*)]`, 'i'))\n      this.tags[tag] = matches && (matches[1] || '')\n    }\n  }\n\n  _initLines() {\n    const lines = this.lrc.split('\\n')\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i]\n      let result = timeExp.exec(line)\n      if (result) {\n        const txt = line.replace(timeExp, '').trim();\n        if (txt) {\n          if (result[3].length === 3) {\n            result[3] = result[3]/10;\n          }\n          this.lines.push({\n            time: result[1] * 60 * 1000 + result[2] * 1000 + (result[3] || 0) * 10,\n            txt\n          })\n        }\n      }\n    }\n\n    this.lines.sort((a, b) => {\n      return a.time - b.time\n    })\n\n  }\n\n  _findcurLineIndex(time) {\n    for (let i = 0; i < this.lines.length; i++) {\n      if (time <= this.lines[i].time) {\n        return i\n      }\n    }\n    return this.lines.length - 1\n  }\n\n  _callHandler(i) {\n    if (i < 0) {\n      return\n    }\n    this.handler({\n      txt: this.lines[i].txt,\n      lineNum: i\n    })\n  }\n\n  _playRest(isSeek=false) {\n    let line = this.lines[this.curLineIndex]\n    let delay;\n    if(isSeek) {\n      delay = line.time - (+new Date() - this.startStamp);\n    }else {\n      //拿到上一行的歌词开始时间，算间隔\n      let preTime = this.lines[this.curLineIndex - 1] ? this.lines[this.curLineIndex - 1].time : 0;\n      delay = line.time - preTime;\n    }\n    this.timer = setTimeout(() => {\n      this._callHandler(this.curLineIndex++)\n      if (this.curLineIndex < this.lines.length && this.state === STATE_PLAYING) {\n        this._playRest()\n      }\n    }, (delay / this.speed))\n  }\n\n  changeSpeed(speed) {\n    this.speed = speed;\n  }\n\n  play(offset = 0, isSeek = false) {\n    if (!this.lines.length) {\n      return\n    }\n    this.state = STATE_PLAYING\n\n    this.curLineIndex = this._findcurLineIndex(offset)\n    //现在正处于第this.curLineIndex-1行\n    this._callHandler(this.curLineIndex-1)\n    this.offset = offset\n    this.startStamp = +new Date() - offset\n\n    if (this.curLineIndex < this.lines.length) {\n      clearTimeout(this.timer)\n      this._playRest(isSeek)\n    }\n  }\n\n  togglePlay(offset) {\n    if (this.state === STATE_PLAYING) {\n      this.stop()\n      this.offset = offset\n    } else {\n      this.state = STATE_PLAYING\n      this.play(offset, true)\n    }\n  }\n\n  stop() {\n    this.state = STATE_PAUSE\n    this.offset = 0\n    clearTimeout(this.timer)\n  }\n\n  seek(offset) {\n    this.play(offset, true)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}